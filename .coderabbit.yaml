# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json

language: en-GB
tone_instructions: >-
  Be friendly, constructive and help colleagues grow their dbt skills. Focus on correctness, data quality, and dbt best
  practices — not cosmetic style. Flag what matters for how code runs and is
  maintained. Acknowledge good work. Open with a summary.
early_access: false

reviews:
  profile: chill
  request_changes_workflow: false
  high_level_summary: true
  high_level_summary_placeholder: "@coderabbitai summary"
  poem: true
  review_status: true
  collapse_walkthrough: true
  sequence_diagrams: true
  changed_files_summary: true
  assess_linked_issues: true
  related_issues: true
  related_prs: true
  suggested_labels: true
  suggested_reviewers: true
  auto_review:
    enabled: true
    drafts: false
    auto_incremental_review: true
  finishing_touches:
    docstrings:
      enabled: false
    unit_tests:
      enabled: false

  path_filters:
    - "!target/**"
    - "!dbt_packages/**"
    - "!logs/**"

  path_instructions:
    # ── Project-wide dbt conventions ──
    - path: "**/*.sql"
      instructions: |
        This is an NHS dbt analytics project on Snowflake. Focus reviews on
        functional correctness, data quality, and dbt best practices — not
        cosmetic style issues. Don't comment on casing, whitespace, comma placement, or line length.

        **Focus areas:**
        - Correctness of joins, filters, and business logic
        - Watch for fan-out joins that silently multiply rows
        - Check that models reference the correct layer (no skipping layers)
        - cluster_by should include person_id where relevant for Snowflake query performance
        - Materialization is set per-layer in dbt_project.yml, override in individual models as needed

        **Naming (only flag if inconsistent with existing patterns):**
        - Booleans prefixed with is_ or has_
        - Dates suffixed with _date, timestamps with _at
        - IDs suffixed with _id
        - snake_case for all column names

    # ── Raw layer ──
    - path: "models/raw/**"
      instructions: |
        Raw models are 1:1 passthroughs from source tables in the DATA_LAKE.
        They are autogenerated and should not be manually edited.
        They rename columns to case insensitive snake_case.
        Flag issues that affect correctness or break the raw layer contract:

        - Must reference source() not ref()
        - No joins, no business logic, no filtering beyond removing true duplicates
        - Filenames start with raw_ prefix
        - Each model should have a paired .yml file

    # ── Staging layer ──
    - path: "models/staging/**"
      instructions: |
        Staging models clean and standardise raw/source data.
        Flag issues that break the staging layer contract:

        - No joins between different source entities
        - Should reference source() or raw_ models via ref(), not downstream models
        - Filenames start with stg_ prefix
        - Each model should have a paired .yml file
        - The generic test test_all_source_columns_in_staging can verify column coverage
        - Most data cleaning should be done in the staging layer, ideally not in modelling.
        - Staging models with complex logic or window functions should be materialised as tables or incremental

    # ── Modelling (intermediate) layer ──
    - path: "models/modelling/**"
      instructions: |
        Modelling (intermediate) models apply business logic and transformations.
        Focus on correctness and data architecture:

        - Each model should serve a single clear purpose
        - Include ALL persons (active, inactive, deceased) — filtering happens downstream
        - Watch for fan-out joins or accidental row duplication
        - Each model should have a clear grain
        - Filenames start with int_ prefix; paired .yml with owner metadata
        - OLIDS models get auto-derived schemas from folder structure (OLIDS_{SUBDOMAIN})
        - OLIDS data carries governance restrictions with applied custom message tags

    # ── Reporting layer ──
    - path: "models/reporting/**"
      instructions: |
        Reporting is our marts layer.
        Reporting models produce analytics-ready datasets.
        Focus on correctness, layer integrity, and test coverage:

        - Should reference modelling-layer models, not raw/staging directly
        - Prefixes: dim_ (dimensions), fct_ (facts), pit_ (point-in-time),
          dq_ (data quality), def_ (definitions)
        - Paired .yml should include owner metadata and PK tests (unique + not_null)
        - Disease registers follow fct_person_{condition}_register pattern
          with indicator metadata (id, type, category, clinical_domain)
        - Flag missing tests on primary keys or important columns

    # ── Published layer ──
    - path: "models/published/**"
      instructions: |
        Published models are production datasets for end users and dashboards.

        - Should only reference reporting-layer models (no skipping layers)
        - direct_care/ → PUBLISHED_REPORTING__DIRECT_CARE database
        - secondary_use/ → PUBLISHED_REPORTING__SECONDARY_USE database
        - OLIDS models in secondary_use get Snowflake governance tags via post-hook
        - Must have paired .yml files
        - User-facing friendly column names are permitted but not required.

    # ── YAML config files ──
    - path: "**/*.yml"
      instructions: |
        YAML files define model metadata, tests, and sources.
        Focus on completeness, not formatting:

        - Each SQL model should have a paired .yml file
        - Primary keys need unique and not_null tests
        - Owner metadata required: config.meta.owner.name
        - Use data_tests (not the deprecated tests key at column level)
        - Auto-generated sources (auto_ prefix) should not be manually edited
        - Sources use quoted identifiers for Snowflake: '"DATABASE"', '"SCHEMA"'

    # ── Macros ──
    - path: "macros/**"
      instructions: |
        Macros provide reusable logic. Focus on correctness and reusability:

        - Organised by purpose: clinical/, transformations/, qof_registers/,
          overrides/, governance/, observability/, campaigns/, utils/
        - New macros should go in the appropriate subdirectory
        - Include a brief comment at the top explaining the macro's purpose
        - Check for edge cases in Jinja logic (null handling, empty lists)

    # ── QOF register macros ──
    - path: "macros/qof_registers/**"
      instructions: |
        QOF register calculation macros. Focus on clinical correctness:

        - Named calculate_{condition}_register.sql
        - Use get_observations() and get_medication_orders() for data retrieval
        - Follow NHS QOF business rules for register inclusion/exclusion
        - Document clinical thresholds, age restrictions, and date logic clearly
        - Called from reporting-layer models

    # ── Tests ──
    - path: "tests/**"
      instructions: |
        Generic and singular tests for data validation.

        - Existing generic tests: test_all_source_columns_in_staging,
          test_bnf_codes_exist, test_cluster_ids_exist, test_no_future_dates,
          test_valuesets_have_codes

chat:
  auto_reply: true

knowledge_base:
  opt_out: false
  learnings:
    scope: local
  issues:
    scope: local
  pull_requests:
    scope: local
